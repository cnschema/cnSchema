本体开发101：创建您第一个本体的指南

Natalya F. Noy 和 Deborah L. McGuinness

# 1  为什么要开发一个本体？

本体(ontology)是指领域概念体系（包括领域术语定义和术语间关系）的形式化规范定义(Gruber 1993)。 近年来，本体开发的工作逐步从人工智能专家的专属领域转移到领域专家的手中。本体在万维网上颇为常见，例如雅虎(yahoo.com)的网站分类体系和亚马逊(Amazon.com)的产品分类与描述体系。万维网联盟（W3C）开发的RDF语言，也即是资源描述框架（Brickley and Guha 1999），支持开发者把网页中的知识表示为机器可解析的格式，从而可以被智能机器人理解并处理。美国国防高级研究计划署（DARPA）与W3C一起，正在通过扩展RDF来开发DARPA智能机器人标记语言（DARPA Agent Markup Lanuguage, DAML。后来升级为W3C的万维网本体语言，Web Ontology  Language，OWL），以更有针对性的构架来促进智能机器人在互联网上的交互（Hendler和McGuinness 2000）。许多学科现在开发了标准化本体以支持领域专家分享和注释领域信息。医学领域出现了大量标准化、结构化的词汇集，例如SNOMED（Price and Spackman 2000）和UMLS（Humphreys and Lindberg 1993）。同时也出现了众多通用本体，例如，联合国开发计划署和美国美国邓白氏公司（Dun＆Bradstreet）共同制定了为产品和服务提供术语的UNSPSC本体（www.unspsc.org）。

为了帮助研究人员在领域中共享信息，本体论定义了常用词汇集，包括机器可理解的领域基本概念及其关系的定义。 那为什么要开发一个本体呢？大致有如下原因：
* 达成信息结构的共识
* 复用领域知识
* 领域规则的显性表示
* 区别领域知识与操作知识
* 分析领域知识


【达成信息结构的共识】是本体开发的常见目标（Musen 1992; Gruber 1993）。例如，当几个不同的网站都包含医疗信息或提供医疗电子商务服务时，如果它们使用相同的底层本体，则只能机器人可以从这些网站中提取并融合信息，进而使用聚合的结果来回答用户查询或作为其他应用程序服务。

【复用领域知识】是本体研究近来激增的动力之一。例如，许多不同领域的模型需要用到时间概念，包括时间区间，时间点，时间的相关度量等。如果有一组研究人员详细研究并定义了这样一个时间本体，那么就可以被其他人直接复用。如果需要构建一个大规模的本体，我们既可以综合若干相关领域的现有本体，也可以从通用本体出发有针对性地扩展领域本体。

【领域规则的显性表示】便于专家有效应对领域知识的变化。领域知识不但包括事实，也包括规则，例如，“鹦鹉是鸟”为事实，“鸟会飞“为规则，那么领域规则的应用就可以推导出”鹦鹉会飞“。如果我们简单地把领域规则用编程的方式表示出来，不但全程依赖程序员支持维护，而且这样的表示亦不利于专家理解与更新。领域规则的显性化表示也便于新用户完整理解领域术语的完整意义。

【区别领域知识与操作知识】是本体的另一个常见用途。正如数据和数据处理流程可以分离，领域应用中不但需要领域知识，同时可以描述如何配置与处理这些领域知识。例如，我们可以定义一个通用的知识图谱问答系统，不但可以使用音乐知识图谱作为数据源，亦可以使用影视知识图谱为数据源。

【分析领域知识】通畅依赖显性的表示领域知识。形式化的术语描述有助与精准地理解领域概念的定义，进而支持知识复用（McGuinness等人，2000）。

构建本体并非领域建模的终点。开发一个本体只是定义了一组数据及其结构。后续的程序（例如推理系统，领域无关的应用程序，或智能机器人）都可以使用本体和基于本体构建的知识库作为输入数据。例如，本文开发了葡萄酒和食物的本体，以及葡萄酒与餐点的合理搭配组合。这个本体可以作为一套餐馆管理工具中应用程序的基础：一个应用程序可以依据当天的菜单创建推荐的葡萄酒或回答服务员和客户的查询。另一个应用程序可以分析一个酒窖的库存列表，并建议今后扩展哪些葡萄酒类别，或是为即将推出的菜单订购搭配的葡萄酒。


## 关于本指南

本文采用Protege-2000（Protege 2000），Ontolingua （Ontolingua 1997），Chimaera（Chimaera 2000）作为本体编辑环境。本指南使用Protege-2000展示本体实例。

本指南中使用的葡萄酒和食品示例源自CLASSIC，一个基于描述逻辑（description logic)的知识表示系统，的论文（Brachman 等人. 1991）以及短教程（McGuinness等人，1994）。 Protege-2000和其他基于框架的系统（frame-based systems) 被用于编辑例子中提到的本体，通过文本和可视化显式说明了分类树体系以及实体所属的具体分类。

本指南中的部分本体设计思想源自于面向对象设计的文献（Rumbaugh et et al。 1991; Booch等人，1997），但是本体开发与面向对象编程中的类和关系的设计有所不同。面向对象的编程主要围绕类的方法，也就是说程序员根据类的操作层面的属性进行设计；而本体设计师根据类的数据结构层面的属性进行设计。

本指南不能解决本体开发人员可能需要处理的所有问题，而是试图提供一些起步性的指导意见，帮助一个新的本体设计师开发新的本体。关于领域建模中的更为复杂数据结构与设计原则，本文点到为止并给出了一些参考资料。

本体设计本身的方法论并无定规，本文的思路主要来源于作者在本体开发中积累的经验。在本指南的结尾也列举了一些替代方法的参考文献.


2 什么是本体

人工智能文献给出了众多不同的本体的定义，甚至有一些是相互矛盾的。在本文中，本体指一个描述性的形式化概念体系，包括实体分类（class/concept, 亦称为概念，简称类，即领域上下文中涉及的概念分类体系），槽位（slot，用于指代实体分类或实体实例的某个特征或属性），角色限制（facet，用于说明槽位与实体分类联合使用时的限制和隐含语义）。一个本体以及由它定义的一组实体实例（instance）在一起就构成一个知识库。这就是本体和知识库的区别。

实体分类（class）描述了领域中的概念，也是大多数本体的重点。例如，“葡萄酒”作为实体分类，可以代表所有类型的葡萄酒。任何一瓶葡萄酒都可以是它的实例。读者面前的一杯波尔多葡萄酒就是实体分类“波尔多葡萄酒”的一个实例。一个实体分类可以细分为更具体的子类（subclass)。例如，我们可以将“葡萄酒”细分为“红葡萄酒”，“白葡萄酒”和“玫瑰葡萄酒”。或者，我们可以基于另外一个分类标准，将“葡萄酒”分成“起泡的葡萄酒”和“不起泡的葡萄酒”。

槽位（slot）描述了实体分类与实体实例的属性。ChâteteLafite Rothschild Pauillac酒具的酒体是full（TODO ），它由ChâteauLafite Rothschild酿酒厂生产。在这个例子中，我们有两个描述葡萄酒的槽位：”酒体"槽位的值为“完整", 而“酿造者”槽位的值为“ChâteauLafite Rothschild酿酒厂”。在实体分类层面，我们可以说，“葡萄酒”一类的所有实例都会描述它们的味道，酒体，糖份比例，酿造者等。[1]  

[1]实体分类的命名采用首字母大写，槽位的命名首字母小写。文中提到的所有概念会用引号标识。

如图1， ”葡萄酒“和它的子类“Pauillac”的所有实例都有一个“酿造者”的槽位，相应的值则是是“酿酒厂”类的某个实例。所有酿酒厂的实例也都有一个槽位 “生产”，指向该酿酒厂生产的“葡萄酒”类实例。

开发本体实践过程一般包括如下步骤
定义实体分类
定义实体分类的分类关系（即子类 - 父类的分类树）
定义槽位以及槽位取值的限制
设定槽位取值的缺省值

此后，我们可以基于本体添加实体实例，从而形成领域知识库。

图1. 葡萄酒领域中的一些类，实例和关系。我们使用黑色的类和红色的实例。直接链接表示槽位和内部链接，例如（TODO）


# 3 简明知识工程方法

正如我们前面所说，开发本体没有一种“完全正确的”方法或方法。本章针对常见问题，介绍开发本体的一种迭代过程。此过程中，先粗略地构建最初的本体，然后不断改进本体并填写细节。在介绍这个过程的同时，我们会讨论设计者如何做出建模决策，以及不同解决方案的优缺点和含义。

首先，我们要强调本体设计中的一些基本规则。这些规则可能看起来很教条。然而，他们可以帮助在许多情况下进行设计决策。
1）领域建模没有一个唯一正确的方式，总有可行的替代方案。最好的解决方案几乎总是取决于您所考虑的应用和您所期望的扩展.
2）本体开发必然是一个迭代过程.
3）本体中的概念应该接近目标领域中对象（不论时物理对象或逻辑对象）和关系。 这些概念很有可能就是来自描述领域的文字中的名词（对象）或动词（关系）。

本体的用途和本体的详细程度规划直接影响建模决策的全过程。本体的直观程度，可扩展性，以及可维护性都是需要权衡的因素。同时，我们也要注意维护本体模型与实际世界的紧密联系。在我们定义本体的初始版本之后，我们可以通过实际应用、解决问题、或与领域专家讨论来对其进行评估和调试。我们几乎肯定需要修改初始本体。迭代设计的这个过程很可能会在本体的整个生命周期中继续下去。

步骤1. 确定本体的领域和范围

我们建议通过定义本体的领域和范围来启动本体的开发。这需要回答几个基本问​​题： （1）本体将涉及的领域是什么？ （2）我们将要如何使用本体？（3）本体表达的信息应解答什么样的问题？ （4）谁将使用和维护本体？上述问题的答案可能在本体设计过程中发生变化，但在任何时间点都有助于限制模型的范围。

以我们之前介绍的葡萄酒和食品的本体为例，（1）食品和葡萄酒就是这个本体的领域；（2）我们计划将该本体用于表达合理搭配葡萄酒和食物的应用；（3）显然本体中应该描述不同类型的葡萄酒，主要食物类型，葡萄酒和食物的合理搭配以及不良组合等概念。同时，我们会忽略其他与葡萄酒和食品相关的概念，例如酿酒厂仓储管理或餐馆员工等概念。（4）如果我们设计的本体将被用在对葡萄酒相关文献的自然语言处理，将概念的同义词和词性信息包含在本体中可能很重要。如果本体将用于帮助餐厅客户决定要订购哪种葡萄酒，我们需要增加零售价格信息。如果用于酒吧饭店等葡萄酒买家，可能需要增加批发定价和批量采购的可能性。如果维护本体的人用不同于本体用户语言的语言描述域，我们可能需要提供多种语言之间的映射。

可用性评价问题。
确定本体范围的一种方法是草拟一个基于本体的知识库应该能够回答的问题的列表，可用性评价问题（competency questions)（Gruninger和Fox 1995）。这些问题可用于对本体设计的可用性评测，例如本体是否包含足够的信息来回答这些类型的问题？答案所需要细节或表示方式？这些问题只是一个草稿，不需要详尽无遗。

在葡萄酒和食品领域，以下是可能的能力问题：
当选择葡萄酒时应考虑葡萄酒的哪种特性？
波尔多是红葡萄酒还是白葡萄酒？ 
赤霞珠是否可以与海鲜合理搭配？ 
与烤肉的最佳搭配的葡萄酒是什么？
哪种葡萄酒的特征影响葡萄酒与菜品的搭配？
不同年份的葡萄酒的芳香与酒体特性会变化吗？
Napa Zinfandel葡萄酒的那些年份品质比较好？

从这个问题列表中可以看出，本体将包括各种葡萄酒的特征，葡萄酒类型，葡萄酒年份，葡萄酒的品质评价，以及对选择合适的葡萄酒有重要意义的食品分类，推荐葡萄酒和食物的合理搭配。

步骤2.考虑重新使用现有的本体

复用别人的工作总是有益的，不必重新发明轮子。看看我们是否可以改进和扩展现有的资源来支持我们的目标领域和任务。如果我们的系统需要与使用特定本体或受控词表的其他应用程序交互，则必须重用现有本体。值得注意的是，许多本体已经以电子数字化形式提供，可以直接导入到您正在使用的本体开发环境中。本体的表达方式往往并不重要，因为许多知识表示软件可以导入导出本体。即使一个知识表示软件不能直接用特定的格式工作，将一个本体从一个格式翻译成另一个格式的任务通常不是一个困难的事情。网络和文学中有可重用本体的本体库。例如，我们可以使用Ontolingua本体库（http://www.ksl.stanford.edu/software/ontolingua/）或DAML本体库（http://www.daml.org/ontologies/）。还有一些公开的商业本体（例如，UNSPSC（www.unspsc.org），RosettaNet（www.rosettanet.org），DMOZ（www.dmoz.org））。

例如，法国葡萄酒的知识库可能已经存在，如果我们可以导入这个知识库和它所基于的本体，那么我们得到的将不仅是法国葡萄酒的分类，还有用于区分葡萄酒类型的初步特征体系。葡萄酒的槽位列表可以很容易地从一些用于购买葡萄酒（www.wines.com等）商业网站上获得， 这也是购买葡萄酒的客户关注的属性。

注意，本指南针对初学者，假设没有已知的相关本体存在，并从头开始开发本体。



步骤3 列举本体中的重要术语
列举所有术语有利于本体开发者向用户陈述或解释本体，说明我们要谈什么术语，这些术语有什么属性，这些属于进一步应该有什么描述。 例如，葡萄酒的重要术语，如葡萄酒，葡萄，酿酒厂，位置，葡萄酒的颜色，身体，风味和糖含量等；不同类型的食物，如鱼和红肉；葡萄酒的亚型如白葡萄酒等等。在项目启动时，最重要的是获得一个相对完整的术语列表，不必担心它们所代表的概念之间的重叠，术语之间的关系，或概念可能具有的任何属性，或者概念是类还是槽位。

接下来的两个步骤包括：（1）开发类的层次结构和（2）定义概念的槽位。这两个步骤相互依赖，首先很难做一个再做另一个。通常，我们在层次结构中创建一些概念的定义，然后通过描述这些概念的属性等来继续。这两个步骤也是本体设计过程中最重要的步骤。我们将在这里简要介绍一下，然后在接下来的两节中讨论需要考虑的更复杂的问题，常见的陷阱，决策等。


步骤4.定义类和类的层次结构

类的层次结构可以通过如下方法构建（Uschold和Gruninger 1996）： 
（1）自上而下的方法，从定义领域中最普遍的概念出发，然后逐步细化概念。例如，可以先为葡萄酒和食品的一般概念创建类。然后再创建“葡萄酒”的子类，例如白葡萄酒，红葡萄酒，玫瑰葡萄酒。我们还可以将“红葡萄酒”进一步分类为西拉(Syrah)，红色勃艮第(Red Burgundy)，赤霞珠（Cabernet Sauvignon)等。
（2）自下而上的方法，从最具体的类出发定义层次结构的叶节点，随后的将这些类别通过分组和抽象组合成更一般的概念。例如，我们从两种葡萄酒Pauillac和Margaux的定义开始，为这两个类创建一个共同的父类Medoc，而Medoc又是波尔多葡萄酒的一个子类。
（3）混合方法综合了自上而下和自下而上的方法，首先定义最突出的概念，然后适当地将其概括和细分。我们开始可能选择几个顶级的概念（如Wine），以及几个具体的概念（如Margaux）。然后，我们将它们与中级概念（如Medoc）相关联。然后可以举一反三，为来自法国的每一个区域的葡萄酒建立相应的类，从而产生一些中间层的概念。

图2显示了不同级别的分类抽象关联层次。

图2.不同级别的葡萄酒分类：葡萄酒，红葡萄酒，白葡萄酒，玫瑰葡萄酒等都是比较一般的顶级概念。 Pauillac和Margaux是层次结构中最具体的底层概念。

上述三种方法各有千秋，读者可以按照自己对领域的认知选择。如果开发者有一个系统的自上而下的领域全局观，那么使用自上而下的方法可能会更容易。组合方法对于许多本体开发人员来说通常是最简单的，因为“中间”概念往往是领域中更具描述性的概念（Rosch 1978）。如果您首先通过区分最一般的分类来认知葡萄酒，那么自上而下的方法可能会更适合你。如果你宁愿从具体的例子开始，自下而上的方法可能更合适。

无论我们选择哪种方法，我们通常从定义类开始。从在步骤3中创建的列表中，我们选择描述具有独立存在的对象的术语，而不是描述这些对象的术语。这些术语将是本体中的类，并将成为类层次结构中的锚点[2]。 通过询问“是否某个类的一个实例必然是另一个类的实例”，我们可以决定类的层级关系。改写为规则就是：“如果A类是B类的父类，那么每个B的实例也是A的一个实例”。

[2]我们也可以将类视为一元谓词（有一个参数的逻辑表达式），例如，“这个对象是一个葡萄酒吗？”，槽位可以看作二元谓词（有两个参数的逻辑表达式），例如，“这个对象的风味是否强大？”“这个对象的味道是什么？”

例如，每瓶“Pinot Noir”酒都是红葡萄酒，所以，“Piont Noir"酒这个类是红葡萄酒（Red Wine）类的子类。
图2显示了葡萄酒（Wine）本体的类层次结构的一部分。第4节包含了定义类层次结构时的进一步详细讨论。

图3. Wine类的槽位和这些槽位的刻面。例如“制造商”槽位旁边的图标“I”表示槽位具有反向（Inverse)的语义，参考第5.1节。

步骤5.定义类的的属性-- 槽位
单靠类是不能提供足够的信息来回答步骤1中的能力问题。一旦我们定义了一些类，我们必须描述概念的内部结构。我们已经从第3步中创建的术语列表中选择了类。大部分剩余术语可能是这些类的属性。这些术语包括例如葡萄酒的颜色，酒体，风味，糖含量以及酿酒厂的位置。对于列表中的每个属性，我们必须确定它们分别描述哪些类。这些属性成为附加到类的槽位。因此，Wine类具有以下槽位：颜色，酒体，味道和糖含量。而酿酒厂将有一个“位置”槽位。

一般来说，有几种类型的对象型属性可以成为本体的槽位：（1） “内在的”属性，如葡萄酒的味道; （2）“外在的”属性，如葡萄酒的名称和产地; （3）组成部分，可以是对象的物理和抽象的“部分”，例如，宴席的一道菜。（4） 与其他个体的关系， 例如，“葡萄酒的酿造者”代表葡萄酒和葡萄酒厂之间的关系，或者“葡萄酒所使用的葡萄”。

因此，除了早先发现属性之外，我们需要在葡萄酒类中添加以下槽位：名称，区域，制造商，葡萄。图3显示了葡萄酒类的槽位。该类的所有子类都会继承该类的槽位。例如，Wine类的所有槽位将被继承到Wine的所有子类，包括Red Wine和White Wine。我们将添加一个额外的槽位，单宁级别（低，中等或高）到红葡萄酒类。“单宁级别”槽位将由红葡萄酒的所有子类（如波尔多和博若莱）继承。一个槽位应该附加在可以具有该属性的最通用的类中。例如，葡萄酒的酒体和颜色应该附在葡萄酒类，因为它是最通用的类​​，其实例将都具有身体和颜色的属性。

步骤6. 定义槽位的刻面（facet）
槽位可以进一步定义不同的刻面（也就是槽位取值的特征）， 例如取值类型，允许的取值，不同取值的数量（基数cadinality）。 例如，葡萄酒的名称是一个字符串，可以定义如下，“葡萄酒”类的“名称”槽位的取值类型是字符串（String）类型。一个槽位同时可以取多个值（例如“酿酒厂生产多种葡萄酒”），并且取值是葡萄酒类的实例（例如 “酿酒厂”的“生产”槽位对应的取值必须来自“葡萄酒”类）。下面描述几个常见的刻面

槽位基数（Slot cardinality）
槽位基数定义了一个槽可以有多少个不同的值。一些系统仅区分单个基数（允许至多一个值）和多个基数（允许任意数量的值）。葡萄酒的酒体为单一基数的槽位（就是说，葡萄酒只能有一个酒体）。由某个酿酒厂生产的葡萄酒允许多个基数槽位（就是说，一个酿酒厂可以生产多种葡萄酒）。一些系统允许指定最小和最大基数，以更精确地描述槽位值的数量。 最小基数为N意味着槽位必须至少具有N个不同的值。例如，葡萄酒的“葡萄”槽位的最小基数为1，就是说每种葡萄酒由至少一种葡萄制成。 最大基数为M表示一个槽位最多可以有M个不同的值。“单一葡萄酒”类的“葡萄”槽位的最大基数为1，就是说此类葡萄酒仅由一种葡萄制成。有时将最大基数设置为0可能很有用，这样的设置将指示该分类的槽位不应该有任何值，例如“企鹅”类虽然是“鸟”类的子类，但是其“最大飞行时间”槽位不应该有取值。

槽位取值类型（Slot-value type)
槽位取值类型描述槽位中可填充哪些类型的值。以下是更常见的值类型的列表： （1）字符串（String）是用于槽位（如“名称”）的最简单的值类型：该值是一个简单的字符串;  （2）数字（Number, 有时使用更多特定的浮点数和整数值类型）描述槽位带数值。例如，葡萄酒的“价格”可以有一个值类型Float （3）布尔指简单的“是”、“否”。例如，如果我们选择不将起泡葡萄酒作为单独的类来表示，葡萄酒是否起泡都可以表示为布尔值：如果值为“true”（“是”）则酒是起泡的，并且如果值为“false”（“否”）则该酒不是起泡的。（4）枚举指定该槽位的特定允许值的列表。例如，我们可以指定风味槽可以承受三个可能的值之一：强，中等和微妙。在Protege-2000中，枚举的槽位是Symbol的类型。(5) 实例类型，允许定义实例之间的关系，定义槽位取值允许哪些类的实例。例如，“酿酒厂”类的“生产”槽位的取值类型为葡萄酒类，也就是选择葡萄酒的实例作为“生产”的取值。[3] 图4显示了“酿酒厂”类中“生产”槽位的定义。

[3]一些系统只是使用一个类来指定值类型，而不需要一个特殊的实例类型槽。

图4. “生产”槽位的刻面定义（描述酒厂生产的葡萄酒）：槽位的基数为“多值”，以及取值类型为“葡萄酒”类的实例。


槽位的定义域（Domain）和值域（Range）
槽位取值类型通常也被称为槽位的值域（Range）。在图4的例子中，葡萄酒类是“生产”槽位的值域。某些系统允许为在槽位与特定的类连接时，进一步限制该槽位的值域。槽位所连接的类（或者槽位所描述的类）称为槽位的定义域，例如酿酒厂类是“生产”槽位的定义域。换言之，在我们将槽位连接到一个类时，槽位所依附的这个类被称为该槽位的定义域。

我们通常采用如下规则确定槽位的定义域或值域：一个槽位的定义域或值域应该适当选择。一方面，不要定义一个过于普遍的定义域或值域：槽位定义域中的所有类的实例都是用该槽位描述，而槽位的任意取值都应该是槽位的值域的某个实例。不建议选取一个范围过大的通用类（例如THING）作为槽位的值域。例如，在描述“酿酒厂”类的“生产”槽位时，我们不必枚举所有的葡萄酒，更不必选择THING--本体中最通用的类，  而是使用“葡萄酒”类作为该槽位的值域。确切地说共有三条原则：
（1）如果一个槽位的值域（或定义域）对应的类列表中同时包含一个类和它的子类，则可以删除该子类。例如，一个槽位的值域同时包含“葡萄酒”类和“红葡萄酒”类，我们可以从值域中删除“红葡萄酒”类。因为此槽位的值域已经隐含地包含了“葡萄酒”类的所有其他子类，红葡萄酒类是葡萄酒类的一个子类，
（2）如果一个槽位的值域（或定义域）对应的类列表中包含了一个A类的所有子类，但是没有没有包括A类，则可以使用A类替换掉它的所有子类。例如，一个槽位的值域若是包括了“红葡萄酒”类，“白葡萄酒”类，“玫瑰葡萄酒”类等“葡萄酒”类的所有子类，我们可以直接指定该槽位的值域为“葡萄酒”类。
 （3）如果一个槽位的值域（或定义域）对应的类列表中包含了一个A类的大多数子类（并非全部），则可以根据实际情况考虑直接只使用A类并去掉这些子类。

再如，设计“单宁水平”的槽位的定义域时，我们可以将该槽位的定义域指定为红葡萄酒的每个子类（例如波尔多，梅洛，博若莱等）。但是因为所有的红葡萄酒都具有“单宁水平”的槽位，所以我们更应该把这个槽位放在这个更通用的“红葡萄酒”类上。进一步指定该槽位的定义域为”葡萄酒“类是不正确得，因为人们不使用“单宁水平”来描述白葡萄酒。

7.创建实例
最后一步是在类的层次结构，为类创建个体实例。定义类的个体实例需要（1）选择一个类，（2）创建该类的个体实例，和（3）填充该实例槽位的值。例如，我们可以创建一个单独的实例Chateau-Morgon-Beaujolais来代表一种特定类型的博若莱葡萄酒，或者说 Chateau-Morgon-Beaujolais是“博若莱葡萄”类的一个实例。此实例具有以下槽位取值（图5）：
酒体=轻；颜色=红色；风味=细腻；单宁水平=低； 葡萄=Gamay（葡萄类的实例）；制造商=Chateau-Morgon（葡萄酒类的实例）； 地区=博若莱（葡萄酒产区类的实例） 糖分：干。

图5.博若莱类的实例的定义。该实例是来自博若莱地区的Chateua Morgon Beaujolais，由Morate酿酒厂酿造的Gamay葡萄制成。它具有酒体轻，口感细腻，红色，单宁含量低。它是干红葡萄酒。


# 4.定义类和类层次结构

本节讨论在定义类和类层次结构（第3节中的步骤4）时需要注意的要点和容易做出的错误。正如我们之前提到的，对于任何给定的领域，并没有唯一正确的类层次结构。类的层次结构取决于本体的可能用途，以及应用程序所需的详细程度、开发者的个人偏好、以及与其他模型兼容的要求。但是，在开发类层次结构时，我们将讨论几个准则。尤其在定义了相当数量的新类之后，回顾并检查新建的层次结构是否符合这些准则是有益的。

4.1确保类层次结构正确
“is-a”关系
我们可以通过“is-a”关系来定义类层次结构。如果B类的每个实例也是A类的一个实例，则A类是B的子类。例如， 霞多丽（Chardonnay）是白葡萄酒的一个子类。分类层次结构亦可以用“是一种”（kind-of)关系描述，例如 霞多丽是一种白葡萄酒；喷气式飞机是一种飞机；肉类是一种食物。
一个类的一个子类代表一个概念，它是父类代表的“一种”概念。

一种葡萄酒不是所有葡萄酒的一个子类。
常见的建模错误是将同一概念的单数和复数版本定义到层次结构中，并使得前者是后者的一个子类。例如，将“葡萄酒”（Wine）类定义为“葡萄酒们”（Wines）的子类是错误的。通过代入“是一种”关系，建模误差就会变得清晰，例如单一的葡萄酒不是一种葡萄酒。避免这种错误的最佳方法是在命名类时统一使用单数或复数（参见第6节关于命名概念的讨论）。

层次关系的传递性
子类关系是传递性的：如果B是A和C的子类是B的子类，然后C是A的一个子类。 例如，我们可以定义一个“葡萄酒”类，然后定义“白葡萄酒”类作为“葡萄酒”的子类。然后我们将霞多丽定义为白葡萄酒的一个子类。子类关系的传递性意味着霞多丽类也是“葡萄酒”的子类。有时我们区分直接子类和间接子类。直接子类是与父类的“最接近”子类，也就是说层次结构中类与其直接子类之间没有其他类。在我们的例子中，霞多丽是白葡萄酒的直接子类，但不是“葡萄酒”的直接子类。

类层次结构的演进
维护一致的类层次结构可能会随着域的发展而变得具有挑战性。例如，多年来所有的Zinfandel葡萄酒都是红色的。因此，我们将一类Zinfandel葡萄酒定义为红酒类的一个子类。然而，有时候葡萄酒酿造商会在酿酒的过程中去掉生色的因素，从而改变葡萄酒的颜色。因此，我们得到粉红色的“白色Zinfandel”。现在我们需要将Zinfandel类分成种，分别是玫瑰色Zinfandel和红色Zinfandel两个类，它们又分别是玫瑰葡萄酒和红葡萄酒的子类。

类和它的名称。
辨别类和它的名称很重要：类表达了领域中的概念，而不是表示这些概念的单词。当我们选择不同的术语体系，类的名称可能会有所差异，但术语本身的概念是不变的。例如，我们可以创建一个类Shrimps，然后将其重命名为Prawns，该类仍然表示相同的概念“虾”。换言之，不论使用Shrimp 还是使用Prawns都是表示“虾”这个概念。 类命名应始终遵循以下规则：概念的同义词都代表同一个类。同义词知识概念的不同称呼。因此，我们不应该同时有一个叫做的Shrimp的类和一个叫做Prawn的类。许多系统允许将在定义类同时关联该类名称的同义词、不同语种的翻译，以及展示形式，或者讲这些包含在类定义的文档中。


避免类循环定义
我们应该避免类层次结构中的循环。当某个类A的一个子类是B并且B也是A的父类时，这样的层次结构中存在一个循环。理论山讲，在层次结构中创建这样一个循环只能说明A类和B类是相等的，换压制所有A的实例是B的实例，B的所有实例也都是A的实例。

4.2分析层次结构中的同级别概念(siblines)
基本定义
层次结构中的同级别概念是指某一个类的所有直接子类（参见第4.1节）。“除了根节点概念外，层次结构中的所有同级别概念应该在同一个粒度层次”。例如，“白葡萄酒”类和“霞多丽”类并非是同一个类的直接子类（比如说葡萄酒类）。白葡萄酒是比霞多丽更为通用的概念。同级别概念的粒度选择类似于书本中的章节组织粒度体系。在这个意义上，类层次结构的与书本纲要的结构类似。

然而，在层次结构的根节点概念（通常表示为一些非常普通的类的直接子类，如Thing）代表了主要的领域知识体系划分，这些概念之间通常不可比，也不需要是类似的概念，属于例外。

判定尺度
一个类直接子类的数量有多少，并没有硬性限制。当然，许多结构良好的本体中都同时存在有两个本体个直接子类的类。我们提供两个指导原则：（1）如果类只有一个直接子类，可能存在建模问题或本体不完整。（2）如果类有十几个子类，则可能需要构建一些中间类。这两个规则类似于列表的排版规则，一个列表中应该不只一个成员，也不应该有太多成员。例如，大多数红勃艮葡萄酒是Cotes d'Or葡萄酒。假设我们只想代表这种大多数“红勃艮第葡萄酒”。我们可以创建一个“红色勃艮第”类，然后创建一个单一的亚类“Cotes d'Or”（图6a）。然而，如果在我们的表示中，“红红色勃艮葡萄酒”和“C tesd'Or葡萄酒”本质上是等价的（所有红葡萄酒都是葡萄酒，所有葡萄酒都是红葡萄酒），那创造“Cotes d'Or”类就不是必需的，并且不会在本体中添加任何新信息。如果我们要包括“Côtes Chalonnaise 葡萄酒“（“Cotes d'Or”南边生产的廉价勃艮第葡萄酒），那么我们可以创建”勃艮第“类的两个直接子类：”Cotes d'Or“ 和”Cotes Chalonnaise“（图6b ）

6.红色勃艮第类的子类。拥有类的单个子类通常说明建模存在问题。

假设将所有类型的葡萄酒列为Wine类的直接子类。然后，这份清单将包括诸如博若莱和波尔多等本体遍的葡萄酒，以及更具体的类型，如Paulliac和Margaux（图7a）。那”葡萄酒类“就会因存在过多的直接子类 而变得不好使用。实际上，为了本体以更有组织的方式反映不同类型的葡萄酒的分类体系，Medoc应该是波尔多的一个子类，而Cote d'Or应该是勃艮第的一个子类。同样具有红葡萄酒和白葡萄酒等中等本体将反映许多人所拥有的葡萄酒领域的概念模型（图7本体对于一大群同级别概念，如果没有众所周知的分类体系，我们也不需要人为地创造新的分类体系。毕竟，本体是现实世界的反映，如果现实世界中没有分类，那么本体应该反映出来。

图7.两种葡萄酒分类层次方案对比：自然的多层次分类体系，对比单一层次的分类体系.


4.3多重继承
大多数知识表示系统允许类层次结构中的多重继承：类可以是几个类的子类。假设我们要创建一个单独的甜品葡萄酒类，甜点葡萄酒类。 Port葡萄酒既是红酒，也是甜点酒。[4]因此，我们定义一个类Port有两个超类：红葡萄酒和甜点酒。 Port类的所有实例都将是红葡萄酒类和甜品酒类的实例。 Port类将从其父母继承其槽位以及对应的刻面。因此，它会继承如下设定：糖分槽位的值为SWEET（来自甜点葡萄酒类），以及”单宁级别“和“颜色”槽位的取值（来自红葡萄酒类）.

[4]我们选择在我们的本体中只代表红色Ports：白色Ports确实存在，但它们是非常罕见。

4.4何时建立一个新类
建模过程中的一个难题就是：什么时候引进一个新类，或何时通过不同的属性值表示差异。不论是充斥无关类的过度细分的复杂层次结构，还是一个把大量分类信息编码在槽位取值中的平坦层次结构都不是很好的知识组织体系。寻找适当的平衡并不容易，所以我们推荐如下几个经验法。

“ 类的子类通常（1）具有父类不具有的附加属性，或（2）槽位的限制与父类不同，或（3）参与到与父类不同的关系中。

例如，红葡萄酒可以具有不同的单宁水平，而该属性一般不用于描述葡萄酒。甜品葡萄酒的”糖“槽的取值是SWEET，但这一取值并不适用于它的所有父类。黑比诺葡萄酒可能会很好地与海鲜搭配，而其他红葡萄酒并非如此。换句话说，我们在层次结构中引入一个新类应该有充分的理由说明，存在一定的场景只能使用这个类，而不能用它的父类来替换。在实践中，增加一个新的子类通常应该添加新的槽位、定义新的槽位取值、或覆盖继承的槽位的某些刻面。当然，即使不引入任何新属性，有时创建新类也是有益的。例如术语层次结构中的类应该对应已有的分类常识，不一定要引入新属性。例如，电子医疗记录系统的本体可以包括各种疾病的分类。这种分类可能只是一种不具有任何属性（或具有相同属性集）的术语层次结构。在这种情况下，使用多层的层次结构而不是单层列表来保存常识中的层次结构仍然是有用的，因为它（1）允许更容易的知识探索和导航，以及（2）便于医生判定术语的一般性粒度。引入不含新属性的新类，也可能有其他原因，例如领域专家可以按常识划分模型概念，即使这些概念本身并无显著区别。本体的人性化设计可以促进领域专家之间以及领域专家和基于知识的系统之间的沟通，通过定义层次体系，我们希望反映专家对本体所表示的领域的认知。

最后，我们不应该为每个额外的限制创建一个类的子类。例如，我们介绍了红葡萄酒，白葡萄酒和玫瑰葡萄酒，因为这种区别是葡萄酒世界中的一个天然的。我们不需要为精致的葡萄酒，温和的葡萄酒等增加分类。当定义类层次结构时，我们的目标是提供有效的知识组织体系，并在创建必要的类和创建太多类之间取得平衡.



4.5 新类或属性值
在领域知识建模时，我们经常需要决定是否把具体的区别（如白色，红色或玫瑰葡萄酒）作为属性值或一组类，而这又取决于领域的范围和手头的任务。例如，我们是创建一个白葡萄酒类，还是简单地创建一个Wine类，并为“颜色”槽位填入不同的值？此问题的答案要因地制宜。具体说，需要按照本体的设计需求，提出下列问题：“白葡萄酒的概念在我们的领域有多重要？”（1） 如果葡萄酒在这个领域只有边缘的重要性，而且葡萄酒是否为白色，对该类与领域中其他类的关系没有任何特别的影响，那么我们不应该为白葡萄酒引入一个单独的类。例如，对于在生产葡萄酒商标的工厂使用的领域模型，任何颜色的葡萄酒商标都是相同的，没有必要为白葡萄酒单独建立一个类。（2）如果为了表示葡萄酒，食物及它们的合理搭配，红葡萄酒与白葡萄酒就会非常不同：二者与不同的食物配对，且具有不同的性质等等。同样，葡萄酒的颜色对于我们可以用来确定葡萄酒品尝体系的葡萄酒知识库也很重要。因此，我们应该为白葡萄酒创建了一个单独的类。

“如果具有不同槽位值的概念成为其他类中不同槽位的限制（值域），我们会建立一个类。否则，我们可以使用同一个类的槽位值来区分这些概念。”

其次，我们的葡萄酒本​​体具有红梅洛和白梅洛等类，而不本体梅洛葡萄酒形成一个单一类。当我们正在开发一个详细的葡萄酒本​​体，我们可以认为红梅洛和白梅洛的确是不同的葡萄酒类型（即使它们是由相同的葡萄酿造的。

“如果一个区别在领域中很重要，我们将不同取值的对象视为不同种类的对象，那么我们应该创建一个新的类来体现去这样的区别”。

考虑一个类的潜本体也有助于决定是否创建一个新的类。
“个别实例所属的类不应该经常更改。”

当我们使用外在而不是内在属性要区分类的概念，这些类的实例将不得不经常从一个类迁移到另一个类。例如，“冷藏葡萄酒”不应该是在餐厅酒单本体中的一个类。“冷藏”应该只是一瓶酒中的属性，因为是否冷藏的状态会经常变化，“冷藏葡萄酒”的一个实例可以很容易地停止成为这个类的一个实例，然后过一段时间再次成为这个类的一个实例。

通常数字，颜色，位置会被定义为是槽位，不需要创建新类。当然葡萄酒是一个显着的例外，因为葡萄酒的颜色对葡萄酒的描述是至关重要的。

有如人体解剖本体。当我们定义肋骨时，我们是否需要为“第一左肋”，“第二左肋”等为分别创建一个类？或者我们是否有一个类包含骨头排列和排列的位置的槽位？[5] 如果在本体中，每个肋骨的描述信息都显著不同，那么我们应该为每个肋骨创建一个类。比如说，如果要表示详细的邻接和位置信息（对于每个肋骨是不同的）以及每个肋骨和它保护的器官的具体功能关系，这些分类就是有必要的。但是，如果我们以稍小的一般性来模拟解剖结构，并且就我们的潜在应用而言，所有的肋骨都非常相似（我们只是谈论在X射线上哪个肋骨断了，但不考虑身体的其他部位）我们可以简化我们的层次结构，这个类型为Rib，并有两个槽位：横向位置，和序号。

[5] 这里我们假设每个解剖器官都是一个类，因为我们也想谈论“约翰的第一左肋骨”。一个人的某个器官将在我们的本体中被表示为实例。


4.6一个实例或一个类？
判定一个特定的概念是本体的一个类还是一个实例，取决于本体的潜在应用场景。本体知识表示的粒度选择决定了类和实例区分的界限，而本体的粒度又由本体的潜在应用决定。换句话说，知识库中最具体的对象是什么？回顾我们在第3节第1步中确定的能力问题，构成答案的最具体的概念是知识库中实例的最佳候选人。

“个体实例是知识库中最具体的概念。”

例如，如果我们只是谈论葡萄酒与食物的合理搭配，而且我们不会对具体的实际的一瓶酒感兴趣，那么诸如Sterling Vineyards Merlot这样的术语可能是我们使用的最具体的术语。因此，Sterling Vineyards Merlot将成为知识库中的一个概念。

另一方面，如果我们想要在餐厅中管理葡萄酒的库存，除了具有良好的葡萄酒食品搭配配对的知识库外，还可以将每一瓶酒变成为我们知识库中的一个实例。

同样，如果我们想为记录不同年份“Sterling Vineyards Merlot”葡萄酒的属性，那么每一个特定年份的“Sterling Vineyards Merlot”葡萄酒都是知识库中的一个实例，这些实例所属的类都是Sterling Vineyards Merlot类。

有些规则可以将一些实例“移动”到一组类中
“如果概念形成一个自然层次结构，那么我们应该将它们表示为一组类“

以葡萄酒产区为例，最初我们可以定义主要葡萄酒产区，如法国，美国，德国等，然后从这些大区域的组成细化定义特定葡萄酒产区。举例说，“勃艮第地区”可以是“法国地区”类的一个实例。但是我们也想说“Cote d'Or地区”是“勃艮第地区”的一部分。这样，“勃艮第地区“就应该是一个类，这样才能有有子类或实例。不过，指定”勃艮第地区“为一个类别，或指定”科特迪瓦地区“是”布戈涅地区“的一个实例，这些做法随意性很强。开发者很难明确区分哪些地区应该类别，而哪些又应该被定义为实例。这样，我们不妨将所有葡萄酒产区都定义为类。 Protege -2本体允许用户将一些类指定为抽象类，表示该本体有任何直接的实例。在我们的例子中，所有地区类都是抽象的（本体。

图8，类名旁边的“A”图标表示这些类是抽象的，不能有任何直接的实例。

如果我们从类名中省略了“地区”这个词，则相同的类层次结构将是不正确的。我们不能说阿尔本体个类是法国的一个子类：阿尔萨斯不“是一种”法国。然而，阿尔萨斯地区“是一种”法国地区。
只有类可才可以被安排在一个层次结构上 - 知识体系中没有一个“子本体的概念。因此，如果术语中本体然本体构，例如在第4.2节的术语层级中，我们应该将这些术语定义为类，即使它们可能没有任何自己的实例.

4.7限制范围

作为定义层次结构的最后一段讨论，以下一组规则用于本体体定义的完整性：
“本体不需要包含有关领域的所有可能信息：您不需要专门（或泛化）超出应用程序的需求（本体专门化或泛化的方向多一层）”

对于我们的葡萄酒和食品的例子，我们不需要知道葡萄酒的商标用什么纸制成或海鲜菜的制作方法。类似地，
“本体不不需要包含所有可能的属性和类之间区别”

在我们的本体中，我们当然不必囊括葡萄酒或食物可能具有的所有属性，而只需要包括我们关注类中最关键的属性。即使葡萄酒书籍告诉我们葡萄的大小，本体中不必非要包括这些知识。同样，我们也不必添加所有在系统中的所有术语之间任意关系。例如，我们在本体中不包括“最受欢迎葡萄酒”和“最受欢迎的食物”等关系。

这条最后的规则本体于限制本体中已有概念之间的关系的范围。以生物学实验的本体为例，本体可能包含生物有机体的概念，还包含执行实验的实验者的概念（以他的名字，隶属关系等）。尽管实验者作为一个人的也恰好是一个生物有机体（也就是说，一个实验者类是成为生物有机体类的一个子类），但我们没有必要将这个区别关系纳入本体。换言之，实验者不是“一种”生物体，因为我们可能永远不会对实验者本身进行实验。在实践中，我们不需要在可预见的应用程序中包含上述子类关系。事实上，引入这个子类关系甚至会带来负面影响：实验者的一个实例将具有与生物有机体有关的重量，年龄，物种和其他数据的槽位，但这些多余的槽位与在描述实验的背景的目标毫不相关。当然我们应该在文档中记录这样设计的决策原因，以便将要查看本体的用户（他们可能不了解本体设计时所考虑的应用场景）

4.8 不相交的子类
许多系统允许我们明确指定几个类是不相交的。如果没有任何共同的实例，两个类是不相交的。例如，我们本体中的甜点葡萄酒和白葡萄酒课程并非不相交：有许多葡萄酒都是两者的实例。例如，“Rothermel Trochenbierenauslese雷司令”（甜点雷司令类的一个实例）。另一方面，红葡萄酒和白葡萄酒课程是不相交的：没有酒可以同时红白相间。指定类是不相交的可以使系统更好地校验本体。如果我们声明
红葡萄酒和白葡萄酒类是不相交的，后来创建同时是雷司令（白葡萄酒的一个子类）和Port（红葡萄酒的一个子类）的子类的一个类时，系统通过推理可以发现此建模错误。



# 5定义属性 - 更多细节
在本节中，我们将针对本体定义槽位（第3节中的步骤5和步骤6）讨论更多细节，特别是一个槽位的反向槽位和默认值.

5.1反向槽位
槽位的一个值可能取决于另一个槽位的值。例如，如果葡萄酒是由酿酒厂生产的，那么酿酒厂就会生产这种葡萄酒。这两个关系，制造者和生产者，被称为反向关系。将信息“双向”存储是多余的。当我们知道葡萄酒是由酿酒厂生产的时候，使用知识库的应用程序总是可以推断酿酒厂产生葡萄酒的反向关系的取值。然而，从知识获取的角度来看，将两条信息显式提供会更为直观。这种方法允许用户在前一种情况下填写酒厂生产的葡萄酒，另一种情况下填写葡萄酒的酿酒厂，而知识获取系统可以自动填写对应反向关系的值，从而确保知识库的一致性。

我们的例子有一对反向的槽位：Wine类的“制造商”槽位和Winery类的“生产”槽位。当用户创建Wine类的实例并填写制造商槽的值时，系统会自动将这个新创建的“葡萄酒”实例添加到相应的Winery实例的“生产”槽中。例如，当我们说Sterling Merlot由Sterling Vineyard酿酒厂生产时，系统会自动将Sterling Merlot添加到Sterling Vineyard酿酒厂生产的葡萄酒列表中（如图9）。

图9.具有反向槽位的实例。酿酒厂“生产”槽位是Wine类的“制造商”槽位的反向槽位。填充其中一个槽位会触发另一个槽位的自动更新.

5.2缺省值
许多基于框架的系统允许为槽位指定缺省值。如果某个类的大多数实例的特定槽位有相同的取值，我们可以将该值定义为槽位的缺省值。然后，当创建包含此槽位的类的每个新实例时，系统将自动填充默认值。然后，我们可以将值更改为槽位刻面允许的其他值。也就是说，缺省值是为了方便起见：它们不会对模型增加任何新的限制或以任何方式更改模型。例如，如果我们要讨论的大多数葡萄酒都是浓郁的葡萄酒，我们可以“完整”作为酒体的缺省值。然后，除非我们另有说明，否则我们定义的所有葡萄酒都将是完整的。请注意，这与槽位的取值（参考槽位的值域定义）不同。槽位的取值是不能更改的。例如，如果甜品葡萄酒类的“糖分”槽位的取值为SWEET，那甜品酒类的所有子类和实例将的“糖分”槽位的取值都是SWEET值，这个值不能在类的任何子类或实例中进行更改。

# 6 什么是名称？
确定本体概念的命名约定，然后严格遵守这些约定不仅使本体更容易理解，而且有助于避免一些常见的建模错误。概念的命名方法可以有很多选择。我们需要本体类和槽位定义形成一个命名约定，并遵守它。“

知识表示系统的以下特征影响命名约定的选择： 系统对于类，槽位和实例有相同的命名空间吗？也就是说，系统是否允许具有相同名称的类和槽位（例如”酒厂“类和“酒厂”槽位）？ 系统是否区分大小写？也就是说，系统是否将不同大小写的名称视为不同的名称（如winery和Winery）？ 系统在名称中允许哪些分隔符？也就是说，名称可以包含空格，逗号，星号等吗？例如，Protege-2000为其所有框架维护一个单一的名称空间。它是区分大小写的。因此，我们不能有重名概念（例如 一个类“酒厂”和一个槽位“酒厂”）。然而，我们可以有一个类“酒厂”(Winery 首字母大写)和一个槽“酒厂”(winery 首字母小写)。另一方面，CLASSIC系统不区分大小写，并为类，槽位和实例维护不同的名称空间。因此，从系统角度来说，一个类和一个槽位都叫Winery在CLASSIC系统里没有任何问题.

6.1大小写和分隔符

首先，如果我们对概念名称使用一致的大小写，我们可以大大提高本体的可读性。例如，通常将类名称首字母大写并使用小写字母为槽位命名（假设系统区分大小写）。当概念名称包含多个单词（例如膳食课程）时，我们需要分隔单词。这里有一些可能的选择。
* 使用空格分隔：“膳食 课程” （Meal Course)（许多系统，包括Protege ，允许概本体中包含空格）。 * 使用驼峰命名法（合并单词并将每个单词大写）：MealCourse 
* 使用下划线或连字符或其他分隔符，例如 Meal_Course，Meal_co本体e，Meal-course，Meal-Course。 （如果您使用分隔符，则还需要确定每个新词是否大写）

如果知识表示系统允许名称中的空格，则使用它们可能是许多本本体人员最直观的解决方案。但是，考虑您系统可能会与其他系统交互，而那些系统不使用空格，或者如果显示媒体不能很好地处理空格符号，可以使用其他本体

6.2单数或复数
类名称表示对象的集合。例如，葡萄酒类实际上代表所有的葡萄酒。因此，一些设计师可以更自然地称之为Wines 而不是Wine。虽然两种方法各有千秋，在实践中更常使用单数形式作为类名称。注意，无论选择什么方案，在整个本体中应该保持一致的命名机制。一些系统甚至要求用户提前声明它们是否将对概念名称使用单数或复数形式，并且不允许用户偏离该选择。始终使用相同的形式也可以防止设计者在建模时犯错误：先建立一个Wines类，然后创建一个类Wine作为其子类（参见第4.1节）.

6.3前缀和后缀约定
一些知识库方法建议在名称中使用前缀和后缀约定来区分类本体。两个常见做法是添加一个前缀“has"或y一个后缀“of" 到槽位名称中。如果我们选择了”has“的约定，我们的槽位名称将成为“has-maker" 或 “has-winery“。如果我们选择了”of"约定，那么这些槽位就成为“maker-of“ 或 “winery-of“。这种方法允许任何看任何术语的人立即确定该术语是一个类还是一个槽位。但是，术语名称变得稍长一些.

6.4其他命名注意事项
定义命名约定还需要考虑以下几点： 
”不要将字符串“class”，“property”，“slot”等添加到概念名称中。“
概念的类型（一个类或是一个槽位）应该很容易从上下文中看清楚。例如，我们可以对类和槽位使用不同的命名约定（例如，首字母大写或全小写）。
通常，避免概念名称中的缩写（通常是一个好主意） ，使用赤霞珠而不是Cab）
直接子类的名称应该同时包括或同时不包括父类的名称。例如，如果我们正在创建Wine类的两个子类来表示红葡萄酒和白葡萄酒，那么这两个子类名称应该是红葡萄酒”Red Wine"和白葡萄酒"White Wine"或White或Red，而不是Red Wine和White.

# 7其他资源
我们已经使用了 protege -2000作为本体的开发环境，为我们的例子。 Duineveld及其同事（Duineveld等人，2000）描述并比较了许多其他本体开发环境。

我们试图解决本体开发的基础知识，并没有讨论过本体开发的许多高级课题或替代方法。 G mez-P rez（G mez-P rez1998）和Uschold（Uschold和Gruninger 1996）提出了替代的本体发展方法。 Ontolingua教程（Farquhar 1997）讨论了知识建模的一些形式化逻辑方法。

目前，研究人员不仅强调本体开发，还强调本体分析。随着更多的本体被生成和重用，更多的工具将可用于分析本体。例如，Chimaera（McGuinness等人，2000）提供了用于分析本体的诊断工具。 Chimaera执行的分析包括检查本体的逻辑正确性和对常见本体设计错误的诊断。本体计师可能希望通过不断发展的本体来运行Chimaera诊断，以确定与常见本体建模实践的一致性.

# 8结论

在本指南中，我们描述了一种用于基于框架的系统的本体开发方法。我们列举了本体开发过程中的步骤，并解决了定义类层次结构和类和实例的属性的复杂问题。然而，遵循所有的规则和建议之后，最重要的事情之一是：对于任何一个域都没有一个正确的本体。本体设计是一个创造性的过程，不同人设计的两个本体不一样。本体和设计者对领域的理解和观点的潜在应用无疑将影响本体设计选择。 “实践出真知” - 我们可以通过应用程序中的使用，来评估我们开发的本体的质量。

